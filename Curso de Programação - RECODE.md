# Curso de ProgramaÃ§Ã£o - RECODE ğŸ’»

Resumo do curso de ProgramaÃ§Ã£o ofertado pela RECODE.

# ğŸ“Œ **SumÃ¡rio**:

1. LÃ³gica de ProgramaÃ§Ã£o e Algoritmo;
2. Linguagens de ProgramaÃ§Ã£o;
3. Ferramentas de ProgramaÃ§Ã£o Visual;
4. Programando com App Inventor.ğŸ“²

# 1. LÃ³gica de ProgramaÃ§Ã£o e Algoritmo:

**Dica**: Fazer exercicios de lÃ³gica para desenvolver o raciocÃ­nio logico. **Site para praticar LÃ³gica de ProgramaÃ§Ã£o jogando**: [https://www.geniol.com.br/logica/desafios/basico-1/](https://www.geniol.com.br/logica/desafios/basico-1/)

**Conceito de LÃ³gica de ProgramaÃ§Ã£o**: Ã‰ possÃ­vel dizer que Ã© uma sequÃªncia de passos de raciocÃ­nio lÃ³gico que temos que seguir atÃ© encontrar a resposta.

**Conceito de LÃ³gica Booleana**: A lÃ³gica booleana incluiu tambÃ©m as negaÃ§Ãµes, asÂ afirmaÃ§Ãµes conjuntasÂ e asÂ  afirmaÃ§Ãµes opcionais. AlÃ©m da negaÃ§Ã£oÂ **(NÃƒO/NO)**,Â as demais postulaÃ§Ãµes da lÃ³gica booleana nos trazem os conceitos de afirmaÃ§Ãµes conjuntasÂ **(E/AND)**,Â e as afirmaÃ§Ãµes opcionaisÂ **(OU/OR)**, classificando seus resultados comoÂ **VERDADEIRO/TRUE** Â ouÂ **FALSO/FALSE.**

![logica booleana.png](https://github.com/jessikahaber/Resumo-de-Cursos-e-Dicas/blob/5859ab791821ad8bac2b18507e02cde26c2b9b78/Curso%20de%20Programa%C3%A7%C3%A3o%20-%20RECODE%20%F0%9F%92%BB%20d8522a8e2214403d9934ae882b94886b/logica_booleana.png)

**ExpressÃµes Boleana**: E/AND, OU/OR, NÃƒO/NO.

**Outras ExpressÃµes**: SE/IF, WHILE, FOR, DO, DO WHILE.

**InterpretaÃ§Ã£o**: Mostram como estas expressÃµes em portuguÃªs seriam interpretadas em lÃ³gica booleana.

**AtenÃ§Ã£o**: Ã‰ recomendado comeÃ§ar o estudo de Algoritmo apenas quando jÃ¡ tiver uma noÃ§Ã£o bem solida de como usar todas as expressÃµes mencionadas acima.

**Conceito de Algoritmos**: SÃ£o conjuntos de passos finitos e organizados que, quando executados, resolvem um determinado problema, ou seja, as etapas tÃªm um inÃ­cio e um fim, ou seja, Ã© programaÃ§Ã£o com instruÃ§Ãµes especÃ­ficas para o alcance de um determinado objetivo. Ã‰ uma **â€œsequÃªncia finita de aÃ§Ãµes executÃ¡veis que visam obter uma soluÃ§Ã£o para um determinado tipo de problemaâ€.**

DisposiÃ§Ã£o especÃ­fica: essa disposiÃ§Ã£o Ã© estruturada e organizada (nome/identificaÃ§Ã£o, ingredientes e modo de preparo).

Estrutura inicial (ingredientes): contÃ©m os recursos necessÃ¡rios para que saia conforme o esperado. 

Estrutura principal (modo de preparo): contÃ©m instruÃ§Ãµes que devem ser executadas numa ordem especÃ­fica e  sequenciada.

# 2. Linguagens de ProgramaÃ§Ã£o:

**Sistema binÃ¡rio**: O computador Ã© um dispositivo eletrÃ´nico e seu funcionamento ocorre por meio deÂ **impulsos elÃ©tricos.** Os impulsos elÃ©tricos sÃ³ permitemÂ **2 estÃ¡gios**:Â **ligado**Â eÂ **desligado**. Quando hÃ¡ corrente de impulso, o computador entende como 1 (um), e quando nÃ£o hÃ¡ corrente de impulso, ele entende como 0 (zero). Logo, o Ãºnico idioma que o computador entende sÃ£o asÂ 
****sequÃªncias de 0 e 1Â , conhecido comoÂ sistema binÃ¡rio****.

**Linguagem de mÃ¡quina**: AÂ **linguagem de mÃ¡quina** chamada tambÃ©m deÂ **linguagem de baixo nÃ­vel,**Â nada mais Ã© do Â que a forma de "falar" com o computador por meio doÂ **idioma binÃ¡rio.** Â Ã‰ a maneira pela qualÂ o computador consegue compreender os comandos. Existem muitas outrasÂ **linguagens de alto nÃ­vel**Â que podemos usar para isso.

1ï¸âƒ£ **Linguagem Compilada**: Perceba que o hardware fala apenas a linguagem de mÃ¡quina, portanto, quanto mais alto o nÃ­vel da linguagem de programaÃ§Ã£o, mais traduÃ§Ãµes sÃ£o necessÃ¡rias paraÂ converter os comandos de alto nÃ­vel em linguagem de mÃ¡quina. As linguagens compiladas estÃ£o ainda presas na arquitetura de hardware do computador, pois, seu funcionamento depende de para qual sistema operacional estÃ¡ sendo compilado (Windows, Linux ou Mac). Por exemplo, a Calculadora do Windows (calc.exe) nÃ£o funciona em nenhum outro sistema operacional diferente deste, pois foi construÃ­da e compilada para a arquitetura da pirÃ¢mide da qual faz parte.

![niveis das linguagens.jpg](https://github.com/jessikahaber/Resumo-de-Cursos-e-Dicas/blob/main/Banco%20de%20imagens/Curso%20de%20Programa%C3%A7%C3%A3o%20-%20RECODE/niveis%20das%20linguagens.jpg)

Fonte: Adaptado de Fonte:Â [www.dsc.ufgc.edu.br](http://www.dsc.ufgc.edu.br/)

Exemplo1: A linguagemÂ **Assembly**Â estÃ¡ bem prÃ³xima da linguagem de mÃ¡quina, entÃ£o sÃ³ precisa de umaÂ **traduÃ§Ã£o ou transformaÃ§Ã£o**.

Exemplo2: JÃ¡ as linguagens de alto nÃ­vel, como oÂ **Fortran**Â ouÂ **C**, precisam serÂ **convertidas** paraÂ **Assembly,**Â que depois Ã© novamente convertida em linguagem de mÃ¡quina.

**TraduÃ§Ãµes ou ConversÃµes:** sÃ£o etapas deÂ **transformaÃ§Ã£o**Â gradual, atÃ© chegar ao nÃ­vel mais baixo de linguagem de mÃ¡quina. Este processo de transformaÃ§Ã£o Ã© chamado deÂ **compilaÃ§Ã£o**.

**Compilador**: transforma os cÃ³digos dos comandos em aplicativos executÃ¡veis de conteÃºdo binÃ¡rio, de baixo nÃ­vel, para que o computador compreenda e execute o que foi programado. O compilador cria um arquivo contendo cÃ³digos binÃ¡rios que podem ser compreendidos e executados.

**Assembly:** Ã© a linguagem que estÃ¡ em umÂ **nÃ­vel muito baixo**, bem prÃ³ximo Ã  linguagem de mÃ¡quina, conforme a figura da pirÃ¢mide que vimos. 

**Fortran:** foi a primeira linguagem de programaÃ§Ã£o deÂ **alto nÃ­vel**, criada em 1954, hÃ¡ quase 70 anos. AtÃ© hoje Ã© utilizada em grandes bancos, devido a sua robustez e eficiÃªncia.

**C/ C++, COBOL e JAVA**: Estas linguagens podem ser escritas em qualquer editor de texto, mas para transformar seus cÃ³digos em um programa de computador Ã© necessÃ¡rio o uso de um compilador.

**VISUAL BASIC, DELPHI, C#**: Estas linguagens, entre outras, precisam de um editor especÃ­fico e proprietÃ¡rio (do fabricante) para construÃ§Ã£o de cÃ³digos, chamados de IDEs (sigla de Integrated Development Environment, ou Ambiente de Desenvolvimento Integrado).

**IDE** (sigla de Integrated Development Environment, ou Ambiente de Desenvolvimento Integrado): Ã© integrada e responsÃ¡vel pela construÃ§Ã£o, execuÃ§Ã£o, compilaÃ§Ã£o, testes e etc., sendo tudo no mesmo ambiente.

2ï¸âƒ£ **Linguagem Interpretada: Algumas linguagens de programaÃ§Ã£o nÃ£o precisam ser compiladas para funcionar.** Elas estÃ£o em um nÃ­vel tÃ£o alto que precisam apenas de outros aplicativos para funcionarem, como um navegador web. Ou seja, o aplicativo pode funcionar em qualquer dispositivo, seja um computador, celular ou TV, sem ter a menor preocupaÃ§Ã£o com o hardware ou o sistema operacional. Estas linguagens sÃ£o totalmenteÂ **independentes**, podendo ser usado qualquerÂ **editor de texto**Â para construir seus cÃ³digos, uma vez queÂ **nÃ£o precisam de compilaÃ§Ã£o**. **Exemplo**: Escrever no bloco de notas um cÃ³digo em hmtl e executar no navegador de internet.

**Tipos de Linguagens interpretadas**: **JavaScript,Â PHP,Â Python**Â entre outras. Por ser independente da arquitetura de hardware do computador, estas linguagens possuem um nÃ­vel ainda mais alto.

3ï¸âƒ£ **Linguagem de ProgramaÃ§Ã£o Visual:** Algumas plataformas como oÂ **Scratch**,Â **Blockly**,Â **Code.org**, entre outras, oferecem um nÃ­vel de linguagem ainda maior, porÃ©m de forma abstrata, realizando a programaÃ§Ã£o de computadores **atravÃ©s de uma linguagem mais visual**.

4ï¸âƒ£ **Prototipagem:** Na Ã¡rea deÂ **construÃ§Ã£o de sistemas**, antes de iniciar aÂ **programaÃ§Ã£o de um projeto**, usamos recursos para criar â€œ**plantas**â€ e â€œ**maquetes**â€ para Â averiguar como o sistema vai ficar, antes de colocar a mÃ£o na massa. A criaÃ§Ã£o de protÃ³tipos traz muitos pontos positivos, como o ganho de produtividade e agilidade na construÃ§Ã£o de um projeto. Depois de criado, podemos transformÃ¡-lo em um projeto no qual jÃ¡ teremos a estrutura inicial produzida.

**Ferramentas de Prototipagem: Figma; Ionic; Tinkercad.**

**Figma:** OÂ **Figma**Â Ã© uma ferramenta, dentre muitas outras existentes, para prototipagem de sites web. Com esta ferramenta, vocÃª pode: Modificar a estrutura do site, cores, tamanhos, imagens, textos etc.; Criar uma navegabilidade (navegaÃ§Ã£o) entre as telas e simular.; Simular como o site vai se comportar em todos os tipo de telas, tais como computadores, tablets e celulares.; Trabalhar em conjunto com outras pessoas, simultaneamente, no mesmo projeto.

Ao final da prototipaÃ§Ã£o do projeto, vocÃª pode exportar o site e terÃ¡ jÃ¡ construÃ­da toda sua estrutura. Agora, com toda esta etapa de construÃ§Ã£o adiantada, vocÃª pode trabalhar apenas na inteligÃªncia e programaÃ§Ã£o do site.

**Ionic:** Semelhante ao Figma, oÂ **Ionic**Â traz elementos para construÃ§Ã£o de interfaces para smartphones em um mesmo projeto - interface paraÂ **Android**Â eÂ **IOS (iPhone)**Â - bastando movimentar a chave para escolher qual sistema vocÃª quer simular. AlÃ©m disso, assim como o Figma, vocÃª pode exportar a estrutura do projeto e iniciar com a interface grÃ¡fica jÃ¡ construÃ­da.

**Tinkercad:** Com ela podemos criar protÃ³tipos de **projetos de robÃ³tica**. Ela permite simular e testar todos os componentes eletrÃ´nicos como se fossem reais, inclusive o cÃ³digo e linguagem de programaÃ§Ã£o do projeto. Ao ficar pronto, basta baixar o cÃ³digo e conectar os componentes reais. Esta ferramenta, diferente das anteriores, permite construir e testar todo o projeto. A plataforma tambÃ©m contÃ©m projetos abertos de outras pessoas, os quais vocÃª pode copiar e aprender mais!

# 3. Ferramentas de ProgramaÃ§Ã£o Visual:

1ï¸âƒ£ **Aprendizado Baseado em Comandos:** 

â–¶ï¸ **Linguagem Logo:** Ã‰ uma plataforma para ensino e aprendizado de lÃ³gica e linguagem de programaÃ§Ã£o. Ã€ primeira vista, Ã© bastante simples, mas ela ensina conceitos de comandos, parÃ¢metros e procedimentos, que formam a base do funcionamento de todas as linguagens de programaÃ§Ã£o.

2ï¸âƒ£ **Aprendizado Baseado em Blocos:** Ã© a construÃ§Ã£o de algoritmos e lÃ³gica de programaÃ§Ã£o por meio da utilizaÃ§Ã£o deÂ blocosÂ de montagem. Esses blocos possuem encaixes especÃ­ficos de acordo com a funÃ§Ã£o e relaÃ§Ã£o entre os conceitos.

****Ferramentas que utilizam o aprendizado em bloco:**** SCRATCH; CODE; BLOCKLY; APP INVENTOR.

â–¶ï¸ **SCRATCH e CODE**: Possui o objetivo de ensinar lÃ³gica de programaÃ§Ã£o de forma mais visual, sem a necessidade de escrita. Em 2013, a organizaÃ§Ã£oÂ **Code.org**, criou uma plataforma com a mesma finalidade, lanÃ§ando â€œ**A Hora do CÃ³digo**â€Â com atividades voltadas para o ensino de ciÃªncia da computaÃ§Ã£o para crianÃ§as.

As duas plataformas tÃªm um funcionamento semelhante, usando a temÃ¡tica de games para ensinar a lÃ³gica de programaÃ§Ã£o baseada em blocos, onde cada bloco da linguagem possui um comando separado e que podem ser agrupados livremente, caso se encaixem. As ferramentas permitem criar jogos elaborados e a aprender muitos dos conceitos da programaÃ§Ã£o, alÃ©m de permitir compartilhar e executar o jogo online.

â–¶ï¸ **BLOCKLY**: Ã‰ uma biblioteca criada pelo Google, de cÃ³digo aberto, permitindo assim a utilizaÃ§Ã£o blocos para construÃ§Ã£o de diversas atividades, tal qual a criaÃ§Ã£o de grÃ¡ficos, formulÃ¡rios e diversas outras possibilidades. Diferentemente doÂ **Scratch**Â e doÂ **Code**, essa ferramenta Ã© mais avanÃ§ada, pois nos dÃ¡ a possibilidade de integraÃ§Ã£o com outras tecnologias de programaÃ§Ã£o, permitindo a criaÃ§Ã£o de blocos especÃ­ficos para cada tipo de projeto.

OÂ **Blockly**Â permite criar e executar seus algoritmos em formato de blocos e a sua visualizaÃ§Ã£o, por exemplo:Â **visualizar como o cÃ³digo ficaria em diferentes liguagens de programaÃ§Ã£o, como JavaScript, Python, PHP, Lua e Dart,**Â conforme a imagem abaixo.

OÂ **Blockly**Â Ã© uma excelente ferramenta para aprendizado sobre o funcionamento e abordagem de diferentes linguagens de programaÃ§Ã£o. Devido ao fato de ser uma biblioteca deÂ cÃ³digoÂ aberto, foi utilizada em diversos projetos para a construÃ§Ã£o de plataformas como o proprioÂ **Code.org**
Â e oÂ **App Inventor.**

â–¶ï¸ **APP INVENTOR**: Esta plataformaÂ ([https://appinventor.mit.edu/](https://appinventor.mit.edu/)) possui um grande diferencial quando comparado Ã s ferramentas anteriores, jÃ¡ que seu projeto Ã© totalmente voltado para celulares, permitindo assim o desenvolvimento de aplicativos totalmente funcionais, rodando diretamente em celulares ou emuladores.

Uma vez criados noÂ **App Inventor**,Â esses aplicativos ficam limitados apenas a arquitetura do sistema operacional Android, por outro lado permite a integraÃ§Ã£o com serviÃ§os Google e recursos tecnolÃ³gicos embarcados nesses celulares, tais como:

- Mapas
- Sensores(GPS, BÃºssola, acelerÃ´metro, etc)
- Armazenamento
- Bluetooth
- Envio de SMS

OÂ **App Inventor**, por trabalhar com cÃ³digo aberto, serviu de base para a criaÃ§Ã£o de outras plataformas concorrentes, como o **Thunkable** e o **Kodular**, que trouxe novas funcionalidades e recursos. As trÃªs plataformas voltadas ao desenvolvimento de aplicativos possuem o mesmo formato de funcionamento.

# 4. Programando com App Inventor:

**App Inventor**:Â Ã‰ uma aplicaÃ§Ã£o em nuvem, gratuita, onde vocÃª pode criar aplicativos para smartphones utilizando a linguagem de programaÃ§Ã£o baseada em blocos. Este tipo de linguagem permite que vocÃª pense no problema e consiga resolvÃª-lo de forma bem simples: arrastando blocos de instruÃ§Ãµes um apÃ³s o outro, ao invÃ©s de programar utilizando apenas texto de pseudocÃ³digo ou atÃ© mesmo usando uma linguagem de programaÃ§Ã£o real e complexa. Leia com atenÃ§Ã£oÂ **O Guia de CriaÃ§Ã£o de Apps**, no site: [https://www.androidpro.com.br/blog/desenvolvimento-android/app-inventor/](https://www.androidpro.com.br/blog/desenvolvimento-android/app-inventor/)

**Configure o App Inventor**: [https://appinventor.mit.edu/explore/ai2/setup](https://appinventor.mit.edu/explore/ai2/setup)

**Outros tutoriais com Projetos PrÃ¡ticos do App Inventor**: [https://appinventor.mit.edu/explore/ai2/tutorials](https://appinventor.mit.edu/explore/ai2/tutorials)

**AtenÃ§Ã£o**: Primeiro faÃ§a a parte visual e depois a lÃ³gica de programaÃ§Ã£o que farÃ¡ o aplicativo ter inteligÃªncia. EstabeleÃ§a qual o objetivo principal do seu app.

**LÃ³gica Condicional:** Possui uma estrutura condicional, onde dependendo da decisÃ£o, um diferente bloco de instruÃ§Ã£o Ã© executado. A lÃ³gica condicional tem a seguinte **estrutura**: **SE/IF, ENTÃƒO/THEN, SENÃƒO/ELSE**. Exemplo: Se a <**condiÃ§Ã£o**> for considerada **verdadeira**, as instruÃ§Ãµes do primeiro bloco (ENTÃƒO/**THEN**) serÃ£o executadas. Se a <**condiÃ§Ã£o**> for **falsa** (nÃ£o Ã© verdadeira), as instruÃ§Ãµes do segundo bloco (SENÃƒO/**ELSE**) serÃ£o executadas.

ğŸ”´ **ClassificaÃ§Ã£o dos operadores**: 

ğŸ”º â€¢ operadores **aritmÃ©ticos (+ (soma), - (subtraÃ§Ã£o), * (multiplicaÃ§Ã£o), / (divisÃ£o)):** o operador aritmÃ©tico para **efetuar uma** **operaÃ§Ã£o matemÃ¡tica.** Assim como na matemÃ¡tica, na programaÃ§Ã£o os operadores seguem uma ordem de precedÃªncia para sua execuÃ§Ã£o. A precedÃªncia de execuÃ§Ã£o os operadores aritmÃ©ticos seguem esta ordem: 

â–ª 1Âº parÃªnteses
â–ª 2Âº potÃªncias e raÃ­zes
â–ª 3Âº multiplicaÃ§Ã£o e divisÃ£o
â–ª 4Âº soma e subtraÃ§Ã£o

ğŸ”º â€¢ operadores de **atribuiÃ§Ã£o (=):** SÃ£o usados para **atribuir um valor Ã  um nome, que chamamos de variÃ¡vel**.

ğŸ”º â€¢ operadores **relacionais (=):** Os operadores relacionais servem para **verificar uma relaÃ§Ã£o entre 2 valores.** O operador relacional de igualdade Ã© usado para **realizar uma comparaÃ§Ã£o de igualdade** entre um valor e outro. **Todos os demais operadores relacionais**:

â€¢ **Igualdade**: este jÃ¡ conhecemos, seu sÃ­mbolo Ã© o sinal de igual, uma ou duas vezes **(â€œ=â€ ou â€œ==â€)**.
â€¢ **DiferenÃ§a ou desigualdade**: Ã© o inverso da igualdade. Verifica se um valor nÃ£o Ã© igual a outro. Seus sinais sÃ£o os sÃ­mbolos de maior-menor juntos **(â€œ<>â€)** ou uma exclamaÃ§Ã£o-igual **(â€œ!=â€)**.
â€¢ **Menor**: verifica se um valor Ã© menor que outro. Seu sÃ­mbolo Ã© o sinal de menor mesmo **(â€œ<â€)**.

â€¢ **Maior**: verifica se um valor Ã© maior que outro. Seu sÃ­mbolo Ã© o sinal de maior mesmo **(â€œ>â€)**.
â€¢ **Menor ou igual**: verifica se um valor Ã© menor ou igual a outro. Seu sÃ­mbolo Ã© um sinal de menor seguido de uma igualdade **(â€œ<=â€)**.
â€¢ **Maior ou igual**: verifica se um valor Ã© maior ou igual a outro. Seu sÃ­mbolo Ã© um sinal de maior seguido de uma igualdade **(â€œ>=â€)**.

**AtenÃ§Ã£o**: Em outras linguagens de programaÃ§Ã£o os operadores de atribuiÃ§Ã£o e igualdade podem sofrer alteraÃ§Ãµes, exemplo: 

| Linguagem de programaÃ§Ã£o | AtribuiÃ§Ã£o | ComparaÃ§Ã£o de igualdade |
| --- | --- | --- |
| Delphi | SalÃ¡rio := 1000 (dois pontos e igual) | Quantidade_Filhos = 0 |
| Java | SalÃ¡rio = 1000 | Quantidade_Filhos == 0 (2 sinais de igual) |
| Shell Script | SalÃ¡rio = 1000 | Quantidade_Filhos eq 0 (eq Ã© sigla de equal, igual em inglÃªs) |

Esta **forma particular** que cada uma usa **para representar seus comandos** Ã© **chamada de sintaxe**.

ğŸ”º â€¢ **Operadores LÃ³gicos:** Os operadores lÃ³gicos sÃ£o: E/**AND,** OU/**OR,** VERDADE/**TRUE,** FALSO/**FALSE, e** NÃƒO/**NOT**. 

Os **operadores lÃ³gicos** AND (E) e OR (OU) funcionam para **verificar se uma expressÃ£o Ã© verdadeira ou falsa** quando existem mais de uma condiÃ§Ã£o que precisam ser testadas. Quando consideramos a expressÃ£o verdadeira, todos os outros resultados possÃ­veis tornam-se falsos.

No **operador AND**, **o resultado** da condiÃ§Ã£o sÃ³ **Ã© verdadeiro** apenas **se todas as condiÃ§Ãµes sÃ£o verdadeiras**.

No **operador OR,** o **resultado** da condiÃ§Ã£o **Ã© verdadeiro** **se pelo menos uma das condiÃ§Ãµes seja verdadeira**, ou seja, o operador OR requer que apenas uma das respostas seja verdadeira, e **a expressÃ£o** **Ã© falsa apenas quando todas as condiÃ§Ãµes sÃ£o falsas**.

Podemos executar trechos de cÃ³digos se uma condiÃ§Ã£o for VERDADEIRA (TRUE) ou outro trecho de cÃ³digo se a mesma condiÃ§Ã£o for FALSA (FALSE) atravÃ©s da estrutura condicional. O IF sempre busca um valor verdadeiro para executar seu trecho de cÃ³digo contido em THEN, nÃ£o sendo verdadeiro (valor falso) ele passa para o trecho contido em ELSE.

Estes **operadores TRUE e FALSE** sÃ£o chamados de **operadores booleanos** e podem funcionar como valores, como se fossem nÃºmeros. 

O funcionamento do **operador NOT** Ã© bem simples, **ele NEGA o conteÃºdo de um valor booleano**, ou seja, se o valor for TRUE, o NOT o transforma em FALSE e vice-versa. Exemplo: NOT TRUE = FALSE, e NOT FALSE = TRUE.
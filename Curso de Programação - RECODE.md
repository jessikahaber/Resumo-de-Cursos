# Curso de ProgramaÃ§Ã£o - RECODE ğŸ’»

Resumo do curso de ProgramaÃ§Ã£o ofertado pela RECODE.

# ğŸ“Œ **SumÃ¡rio**:

1. LÃ³gica de ProgramaÃ§Ã£o e Algoritmo;
2. Linguagens de ProgramaÃ§Ã£o;
3. Ferramentas de ProgramaÃ§Ã£o Visual;
4. Programando com App Inventor.ğŸ“²

# 1. LÃ³gica de ProgramaÃ§Ã£o e Algoritmo:

**Dica**: Fazer exercicios de lÃ³gica para desenvolver o raciocÃ­nio logico. **Site para praticar LÃ³gica de ProgramaÃ§Ã£o jogando**: [https://www.geniol.com.br/logica/desafios/basico-1/](https://www.geniol.com.br/logica/desafios/basico-1/)

**Conceito de LÃ³gica de ProgramaÃ§Ã£o**: Ã‰ possÃ­vel dizer que Ã© uma sequÃªncia de passos de raciocÃ­nio lÃ³gico que temos que seguir atÃ© encontrar a resposta.

**Conceito de LÃ³gica Booleana**: A lÃ³gica booleana incluiu tambÃ©m as negaÃ§Ãµes, asÂ afirmaÃ§Ãµes conjuntasÂ e asÂ  afirmaÃ§Ãµes opcionais. AlÃ©m da negaÃ§Ã£oÂ **(NÃƒO/NO)**,Â as demais postulaÃ§Ãµes da lÃ³gica booleana nos trazem os conceitos de afirmaÃ§Ãµes conjuntasÂ **(E/AND)**,Â e as afirmaÃ§Ãµes opcionaisÂ **(OU/OR)**, classificando seus resultados comoÂ **VERDADEIRO/TRUE** Â ouÂ **FALSO/FALSE.**

![logica booleana.png](https://github.com/jessikahaber/Resumo-de-Cursos-e-Dicas/blob/5859ab791821ad8bac2b18507e02cde26c2b9b78/Curso%20de%20Programa%C3%A7%C3%A3o%20-%20RECODE%20%F0%9F%92%BB%20d8522a8e2214403d9934ae882b94886b/logica_booleana.png)

**ExpressÃµes Boleana**: E/AND, OU/OR, NÃƒO/NO.

**Outras ExpressÃµes**: SE/IF, WHILE, FOR, DO, DO WHILE.

**InterpretaÃ§Ã£o**: Mostram como estas expressÃµes em portuguÃªs seriam interpretadas em lÃ³gica booleana.

**AtenÃ§Ã£o**: Ã‰ recomendado comeÃ§ar o estudo de Algoritmo apenas quando jÃ¡ tiver uma noÃ§Ã£o bem solida de como usar todas as expressÃµes mencionadas acima.

**Conceito de Algoritmos**: SÃ£o conjuntos de passos finitos e organizados que, quando executados, resolvem um determinado problema, ou seja, as etapas tÃªm um inÃ­cio e um fim, ou seja, Ã© programaÃ§Ã£o com instruÃ§Ãµes especÃ­ficas para o alcance de um determinado objetivo. Ã‰ uma **â€œsequÃªncia finita de aÃ§Ãµes executÃ¡veis que visam obter uma soluÃ§Ã£o para um determinado tipo de problemaâ€.**

DisposiÃ§Ã£o especÃ­fica: essa disposiÃ§Ã£o Ã© estruturada e organizada (nome/identificaÃ§Ã£o, ingredientes e modo de preparo).

Estrutura inicial (ingredientes): contÃ©m os recursos necessÃ¡rios para que saia conforme o esperado. 

Estrutura principal (modo de preparo): contÃ©m instruÃ§Ãµes que devem ser executadas numa ordem especÃ­fica e  sequenciada.

# 2. Linguagens de ProgramaÃ§Ã£o:

**Sistema binÃ¡rio**: O computador Ã© um dispositivo eletrÃ´nico e seu funcionamento ocorre por meio deÂ **impulsos elÃ©tricos.** Os impulsos elÃ©tricos sÃ³ permitemÂ **2 estÃ¡gios**:Â **ligado**Â eÂ **desligado**. Quando hÃ¡ corrente de impulso, o computador entende como 1 (um), e quando nÃ£o hÃ¡ corrente de impulso, ele entende como 0 (zero). Logo, o Ãºnico idioma que o computador entende sÃ£o asÂ 
****sequÃªncias de 0 e 1Â , conhecido comoÂ sistema binÃ¡rio****.

**Linguagem de mÃ¡quina**: AÂ **linguagem de mÃ¡quina** chamada tambÃ©m deÂ **linguagem de baixo nÃ­vel,**Â nada mais Ã© do Â que a forma de "falar" com o computador por meio doÂ **idioma binÃ¡rio.** Â Ã‰ a maneira pela qualÂ o computador consegue compreender os comandos. Existem muitas outrasÂ **linguagens de alto nÃ­vel**Â que podemos usar para isso.

1ï¸âƒ£ **Linguagem Compilada**: Perceba que o hardware fala apenas a linguagem de mÃ¡quina, portanto, quanto mais alto o nÃ­vel da linguagem de programaÃ§Ã£o, mais traduÃ§Ãµes sÃ£o necessÃ¡rias paraÂ converter os comandos de alto nÃ­vel em linguagem de mÃ¡quina. As linguagens compiladas estÃ£o ainda presas na arquitetura de hardware do computador, pois, seu funcionamento depende de para qual sistema operacional estÃ¡ sendo compilado (Windows, Linux ou Mac). Por exemplo, a Calculadora do Windows (calc.exe) nÃ£o funciona em nenhum outro sistema operacional diferente deste, pois foi construÃ­da e compilada para a arquitetura da pirÃ¢mide da qual faz parte.

![niveis das linguagens.jpg](https://github.com/jessikahaber/Resumo-de-Cursos-e-Dicas/blob/main/Banco%20de%20imagens/Curso%20de%20Programa%C3%A7%C3%A3o%20-%20RECODE/niveis%20das%20linguagens.jpg)

Fonte: Adaptado de Fonte:Â [www.dsc.ufgc.edu.br](http://www.dsc.ufgc.edu.br/)

Exemplo1: A linguagemÂ **Assembly**Â estÃ¡ bem prÃ³xima da linguagem de mÃ¡quina, entÃ£o sÃ³ precisa de umaÂ **traduÃ§Ã£o ou transformaÃ§Ã£o**.

Exemplo2: JÃ¡ as linguagens de alto nÃ­vel, como oÂ **Fortran**Â ouÂ **C**, precisam serÂ **convertidas** paraÂ **Assembly,**Â que depois Ã© novamente convertida em linguagem de mÃ¡quina.

**TraduÃ§Ãµes ou ConversÃµes:** sÃ£o etapas deÂ **transformaÃ§Ã£o**Â gradual, atÃ© chegar ao nÃ­vel mais baixo de linguagem de mÃ¡quina. Este processo de transformaÃ§Ã£o Ã© chamado deÂ **compilaÃ§Ã£o**.

**Compilador**: transforma os cÃ³digos dos comandos em aplicativos executÃ¡veis de conteÃºdo binÃ¡rio, de baixo nÃ­vel, para que o computador compreenda e execute o que foi programado. O compilador cria um arquivo contendo cÃ³digos binÃ¡rios que podem ser compreendidos e executados.

**Assembly:** Ã© a linguagem que estÃ¡ em umÂ **nÃ­vel muito baixo**, bem prÃ³ximo Ã  linguagem de mÃ¡quina, conforme a figura da pirÃ¢mide que vimos. 

**Fortran:** foi a primeira linguagem de programaÃ§Ã£o deÂ **alto nÃ­vel**, criada em 1954, hÃ¡ quase 70 anos. AtÃ© hoje Ã© utilizada em grandes bancos, devido a sua robustez e eficiÃªncia.

**C/ C++, COBOL e JAVA**: Estas linguagens podem ser escritas em qualquer editor de texto, mas para transformar seus cÃ³digos em um programa de computador Ã© necessÃ¡rio o uso de um compilador.

**VISUAL BASIC, DELPHI, C#**: Estas linguagens, entre outras, precisam de um editor especÃ­fico e proprietÃ¡rio (do fabricante) para construÃ§Ã£o de cÃ³digos, chamados de IDEs (sigla de Integrated Development Environment, ou Ambiente de Desenvolvimento Integrado).

**IDE** (sigla de Integrated Development Environment, ou Ambiente de Desenvolvimento Integrado): Ã© integrada e responsÃ¡vel pela construÃ§Ã£o, execuÃ§Ã£o, compilaÃ§Ã£o, testes e etc., sendo tudo no mesmo ambiente.

2ï¸âƒ£ **Linguagem Interpretada: Algumas linguagens de programaÃ§Ã£o nÃ£o precisam ser compiladas para funcionar.** Elas estÃ£o em um nÃ­vel tÃ£o alto que precisam apenas de outros aplicativos para funcionarem, como um navegador web. Ou seja, o aplicativo pode funcionar em qualquer dispositivo, seja um computador, celular ou TV, sem ter a menor preocupaÃ§Ã£o com o hardware ou o sistema operacional. Estas linguagens sÃ£o totalmenteÂ **independentes**, podendo ser usado qualquerÂ **editor de texto**Â para construir seus cÃ³digos, uma vez queÂ **nÃ£o precisam de compilaÃ§Ã£o**. **Exemplo**: Escrever no bloco de notas um cÃ³digo em hmtl e executar no navegador de internet.

**Tipos de Linguagens interpretadas**: **JavaScript,Â PHP,Â Python**Â entre outras. Por ser independente da arquitetura de hardware do computador, estas linguagens possuem um nÃ­vel ainda mais alto.

3ï¸âƒ£ **Linguagem de ProgramaÃ§Ã£o Visual:** Algumas plataformas como oÂ **Scratch**,Â **Blockly**,Â **Code.org**, entre outras, oferecem um nÃ­vel de linguagem ainda maior, porÃ©m de forma abstrata, realizando a programaÃ§Ã£o de computadores **atravÃ©s de uma linguagem mais visual**.

4ï¸âƒ£ **Prototipagem:** Na Ã¡rea deÂ **construÃ§Ã£o de sistemas**, antes de iniciar aÂ **programaÃ§Ã£o de um projeto**, usamos recursos para criar â€œ**plantas**â€ e â€œ**maquetes**â€ para Â averiguar como o sistema vai ficar, antes de colocar a mÃ£o na massa. A criaÃ§Ã£o de protÃ³tipos traz muitos pontos positivos, como o ganho de produtividade e agilidade na construÃ§Ã£o de um projeto. Depois de criado, podemos transformÃ¡-lo em um projeto no qual jÃ¡ teremos a estrutura inicial produzida.

**Ferramentas de Prototipagem: Figma; Ionic; Tinkercad.**

**Figma:** OÂ **Figma**Â Ã© uma ferramenta, dentre muitas outras existentes, para prototipagem de sites web. Com esta ferramenta, vocÃª pode: Modificar a estrutura do site, cores, tamanhos, imagens, textos etc.; Criar uma navegabilidade (navegaÃ§Ã£o) entre as telas e simular.; Simular como o site vai se comportar em todos os tipo de telas, tais como computadores, tablets e celulares.; Trabalhar em conjunto com outras pessoas, simultaneamente, no mesmo projeto.

Ao final da prototipaÃ§Ã£o do projeto, vocÃª pode exportar o site e terÃ¡ jÃ¡ construÃ­da toda sua estrutura. Agora, com toda esta etapa de construÃ§Ã£o adiantada, vocÃª pode trabalhar apenas na inteligÃªncia e programaÃ§Ã£o do site.

**Ionic:** Semelhante ao Figma, oÂ **Ionic**Â traz elementos para construÃ§Ã£o de interfaces para smartphones em um mesmo projeto - interface paraÂ **Android**Â eÂ **IOS (iPhone)**Â - bastando movimentar a chave para escolher qual sistema vocÃª quer simular. AlÃ©m disso, assim como o Figma, vocÃª pode exportar a estrutura do projeto e iniciar com a interface grÃ¡fica jÃ¡ construÃ­da.

**Tinkercad:** Com ela podemos criar protÃ³tipos de **projetos de robÃ³tica**. Ela permite simular e testar todos os componentes eletrÃ´nicos como se fossem reais, inclusive o cÃ³digo e linguagem de programaÃ§Ã£o do projeto. Ao ficar pronto, basta baixar o cÃ³digo e conectar os componentes reais. Esta ferramenta, diferente das anteriores, permite construir e testar todo o projeto. A plataforma tambÃ©m contÃ©m projetos abertos de outras pessoas, os quais vocÃª pode copiar e aprender mais!

# 3. Ferramentas de ProgramaÃ§Ã£o Visual:

1ï¸âƒ£ **Aprendizado Baseado em Comandos:** 

â–¶ï¸ **Linguagem Logo:** Ã‰ uma plataforma para ensino e aprendizado de lÃ³gica e linguagem de programaÃ§Ã£o. Ã€ primeira vista, Ã© bastante simples, mas ela ensina conceitos de comandos, parÃ¢metros e procedimentos, que formam a base do funcionamento de todas as linguagens de programaÃ§Ã£o.

2ï¸âƒ£ **Aprendizado Baseado em Blocos:** Ã© a construÃ§Ã£o de algoritmos e lÃ³gica de programaÃ§Ã£o por meio da utilizaÃ§Ã£o deÂ blocosÂ de montagem. Esses blocos possuem encaixes especÃ­ficos de acordo com a funÃ§Ã£o e relaÃ§Ã£o entre os conceitos.

****Ferramentas que utilizam o aprendizado em bloco:**** SCRATCH; CODE; BLOCKLY; APP INVENTOR.

â–¶ï¸ **SCRATCH e CODE**: Possui o objetivo de ensinar lÃ³gica de programaÃ§Ã£o de forma mais visual, sem a necessidade de escrita. Em 2013, a organizaÃ§Ã£oÂ **Code.org**, criou uma plataforma com a mesma finalidade, lanÃ§ando â€œ**A Hora do CÃ³digo**â€Â com atividades voltadas para o ensino de ciÃªncia da computaÃ§Ã£o para crianÃ§as.

As duas plataformas tÃªm um funcionamento semelhante, usando a temÃ¡tica de games para ensinar a lÃ³gica de programaÃ§Ã£o baseada em blocos, onde cada bloco da linguagem possui um comando separado e que podem ser agrupados livremente, caso se encaixem. As ferramentas permitem criar jogos elaborados e a aprender muitos dos conceitos da programaÃ§Ã£o, alÃ©m de permitir compartilhar e executar o jogo online.

â–¶ï¸ **BLOCKLY**: Ã‰ uma biblioteca criada pelo Google, de cÃ³digo aberto, permitindo assim a utilizaÃ§Ã£o blocos para construÃ§Ã£o de diversas atividades, tal qual a criaÃ§Ã£o de grÃ¡ficos, formulÃ¡rios e diversas outras possibilidades. Diferentemente doÂ **Scratch**Â e doÂ **Code**, essa ferramenta Ã© mais avanÃ§ada, pois nos dÃ¡ a possibilidade de integraÃ§Ã£o com outras tecnologias de programaÃ§Ã£o, permitindo a criaÃ§Ã£o de blocos especÃ­ficos para cada tipo de projeto.

OÂ **Blockly**Â permite criar e executar seus algoritmos em formato de blocos e a sua visualizaÃ§Ã£o, por exemplo:Â **visualizar como o cÃ³digo ficaria em diferentes liguagens de programaÃ§Ã£o, como JavaScript, Python, PHP, Lua e Dart,**Â conforme a imagem abaixo.

OÂ **Blockly**Â Ã© uma excelente ferramenta para aprendizado sobre o funcionamento e abordagem de diferentes linguagens de programaÃ§Ã£o. Devido ao fato de ser uma biblioteca deÂ cÃ³digoÂ aberto, foi utilizada em diversos projetos para a construÃ§Ã£o de plataformas como o proprioÂ **Code.org**
Â e oÂ **App Inventor.**

â–¶ï¸ **APP INVENTOR**: Esta plataformaÂ ([https://appinventor.mit.edu/](https://appinventor.mit.edu/)) possui um grande diferencial quando comparado Ã s ferramentas anteriores, jÃ¡ que seu projeto Ã© totalmente voltado para celulares, permitindo assim o desenvolvimento de aplicativos totalmente funcionais, rodando diretamente em celulares ou emuladores.

Uma vez criados noÂ **App Inventor**,Â esses aplicativos ficam limitados apenas a arquitetura do sistema operacional Android, por outro lado permite a integraÃ§Ã£o com serviÃ§os Google e recursos tecnolÃ³gicos embarcados nesses celulares, tais como:

- Mapas
- Sensores(GPS, BÃºssola, acelerÃ´metro, etc)
- Armazenamento
- Bluetooth
- Envio de SMS

OÂ **App Inventor**, por trabalhar com cÃ³digo aberto, serviu de base para a criaÃ§Ã£o de outras plataformas concorrentes, como o **Thunkable** e o **Kodular**, que trouxe novas funcionalidades e recursos. As trÃªs plataformas voltadas ao desenvolvimento de aplicativos possuem o mesmo formato de funcionamento.

# 4. Programando com App Inventor:

**App Inventor**:Â Ã‰ uma aplicaÃ§Ã£o em nuvem, gratuita, onde vocÃª pode criar aplicativos para smartphones utilizando a linguagem de programaÃ§Ã£o baseada em blocos. Este tipo de linguagem permite que vocÃª pense no problema e consiga resolvÃª-lo de forma bem simples: arrastando blocos de instruÃ§Ãµes um apÃ³s o outro, ao invÃ©s de programar utilizando apenas texto de pseudocÃ³digo ou atÃ© mesmo usando uma linguagem de programaÃ§Ã£o real e complexa. Leia com atenÃ§Ã£oÂ **O Guia de CriaÃ§Ã£o de Apps**, no site: [https://www.androidpro.com.br/blog/desenvolvimento-android/app-inventor/](https://www.androidpro.com.br/blog/desenvolvimento-android/app-inventor/)

**Configure o App Inventor**: [https://appinventor.mit.edu/explore/ai2/setup](https://appinventor.mit.edu/explore/ai2/setup)

**Outros tutoriais com Projetos PrÃ¡ticos do App Inventor**: [https://appinventor.mit.edu/explore/ai2/tutorials](https://appinventor.mit.edu/explore/ai2/tutorials)

**AtenÃ§Ã£o**: Primeiro faÃ§a a parte visual e depois a lÃ³gica de programaÃ§Ã£o que farÃ¡ o aplicativo ter inteligÃªncia. EstabeleÃ§a qual o objetivo principal do seu app.

**LÃ³gica Condicional:** Possui uma estrutura condicional, onde dependendo da decisÃ£o, um diferente bloco de instruÃ§Ã£o Ã© executado. A lÃ³gica condicional tem a seguinte **estrutura**: **SE/IF, ENTÃƒO/THEN, SENÃƒO/ELSE**. Exemplo: Se a <**condiÃ§Ã£o**> for considerada **verdadeira**, as instruÃ§Ãµes do primeiro bloco (ENTÃƒO/**THEN**) serÃ£o executadas. Se a <**condiÃ§Ã£o**> for **falsa** (nÃ£o Ã© verdadeira), as instruÃ§Ãµes do segundo bloco (SENÃƒO/**ELSE**) serÃ£o executadas.

ğŸ”´ **ClassificaÃ§Ã£o dos operadores**: 

ğŸ”º â€¢ operadores **aritmÃ©ticos (+ (soma), - (subtraÃ§Ã£o), * (multiplicaÃ§Ã£o), / (divisÃ£o)):** o operador aritmÃ©tico para **efetuar uma** **operaÃ§Ã£o matemÃ¡tica.** Assim como na matemÃ¡tica, na programaÃ§Ã£o os operadores seguem uma ordem de precedÃªncia para sua execuÃ§Ã£o. A precedÃªncia de execuÃ§Ã£o os operadores aritmÃ©ticos seguem esta ordem: 

â–ª 1Âº parÃªnteses
â–ª 2Âº potÃªncias e raÃ­zes
â–ª 3Âº multiplicaÃ§Ã£o e divisÃ£o
â–ª 4Âº soma e subtraÃ§Ã£o

ğŸ”º â€¢ operadores de **atribuiÃ§Ã£o (=):** SÃ£o usados para **atribuir um valor Ã  um nome, que chamamos de variÃ¡vel**.

ğŸ”º â€¢ operadores **relacionais (=):** Os operadores relacionais servem para **verificar uma relaÃ§Ã£o entre 2 valores.** O operador relacional de igualdade Ã© usado para **realizar uma comparaÃ§Ã£o de igualdade** entre um valor e outro. **Todos os demais operadores relacionais**:

â€¢ **Igualdade**: este jÃ¡ conhecemos, seu sÃ­mbolo Ã© o sinal de igual, uma ou duas vezes **(â€œ=â€ ou â€œ==â€)**.

â€¢ **DiferenÃ§a ou desigualdade**: Ã© o inverso da igualdade. Verifica se um valor nÃ£o Ã© igual a outro. Seus sinais sÃ£o os sÃ­mbolos de maior-menor juntos **(â€œ<>â€)** ou uma exclamaÃ§Ã£o-igual **(â€œ!=â€)**.

â€¢ **Menor**: verifica se um valor Ã© menor que outro. Seu sÃ­mbolo Ã© o sinal de menor mesmo **(â€œ<â€)**.

â€¢ **Maior**: verifica se um valor Ã© maior que outro. Seu sÃ­mbolo Ã© o sinal de maior mesmo **(â€œ>â€)**.

â€¢ **Menor ou igual**: verifica se um valor Ã© menor ou igual a outro. Seu sÃ­mbolo Ã© um sinal de menor seguido de uma igualdade **(â€œ<=â€)**.

â€¢ **Maior ou igual**: verifica se um valor Ã© maior ou igual a outro. Seu sÃ­mbolo Ã© um sinal de maior seguido de uma igualdade **(â€œ>=â€)**.

**AtenÃ§Ã£o**: Em outras linguagens de programaÃ§Ã£o os operadores de atribuiÃ§Ã£o e igualdade podem sofrer alteraÃ§Ãµes, exemplo: 

| Linguagem de programaÃ§Ã£o | AtribuiÃ§Ã£o | ComparaÃ§Ã£o de igualdade |
| --- | --- | --- |
| Delphi | SalÃ¡rio := 1000 (dois pontos e igual) | Quantidade_Filhos = 0 |
| Java | SalÃ¡rio = 1000 | Quantidade_Filhos == 0 (2 sinais de igual) |
| Shell Script | SalÃ¡rio = 1000 | Quantidade_Filhos eq 0 (eq Ã© sigla de equal, igual em inglÃªs) |

Esta **forma particular** que cada uma usa **para representar seus comandos** Ã© **chamada de sintaxe**.

ğŸ”º â€¢ **Operadores LÃ³gicos:** Os operadores lÃ³gicos sÃ£o: E/**AND,** OU/**OR,** VERDADE/**TRUE,** FALSO/**FALSE, e** NÃƒO/**NOT**. 

Os **operadores lÃ³gicos** AND (E) e OR (OU) funcionam para **verificar se uma expressÃ£o Ã© verdadeira ou falsa** quando existem mais de uma condiÃ§Ã£o que precisam ser testadas. Quando consideramos a expressÃ£o verdadeira, todos os outros resultados possÃ­veis tornam-se falsos.

No **operador AND**, **o resultado** da condiÃ§Ã£o sÃ³ **Ã© verdadeiro** apenas **se todas as condiÃ§Ãµes sÃ£o verdadeiras**.

No **operador OR,** o **resultado** da condiÃ§Ã£o **Ã© verdadeiro** **se pelo menos uma das condiÃ§Ãµes seja verdadeira**, ou seja, o operador OR requer que apenas uma das respostas seja verdadeira, e **a expressÃ£o** **Ã© falsa apenas quando todas as condiÃ§Ãµes sÃ£o falsas**.

Podemos executar trechos de cÃ³digos se uma condiÃ§Ã£o for VERDADEIRA (TRUE) ou outro trecho de cÃ³digo se a mesma condiÃ§Ã£o for FALSA (FALSE) atravÃ©s da estrutura condicional. O IF sempre busca um valor verdadeiro para executar seu trecho de cÃ³digo contido em THEN, nÃ£o sendo verdadeiro (valor falso) ele passa para o trecho contido em ELSE.

Estes **operadores TRUE e FALSE** sÃ£o chamados de **operadores booleanos** e podem funcionar como valores, como se fossem nÃºmeros. 

O funcionamento do **operador NOT** Ã© bem simples, **ele NEGA o conteÃºdo de um valor booleano**, ou seja, se o valor for TRUE, o NOT o transforma em FALSE e vice-versa. Exemplo: NOT TRUE = FALSE, e NOT FALSE = TRUE.

ğŸ”´ **VariÃ¡veis e Constantes:**

ğŸ”º **VariÃ¡veis**: As variÃ¡veis sÃ£o locais onde **podemos armazenar valores** e, como o nome diz, podem ser alterados ao longo do algoritmo, ou seja, podem ter seus valores variados, podem ter variaÃ§Ã£o. As variÃ¡veis tÃªm este nome pois hÃ¡ um outro tipo de armazenamento de valores que **nÃ£o permitem a mudanÃ§a de seu valor ao longo do cÃ³digo, sÃ£o as chamados constantes**.

ğŸ”º **Constantes:** A constante **nÃ£o permite alterar seu valor depois que definido**, mantendo os valores constantes, conforme seu nome.

1ï¸âƒ£ **Tipos de dados com o qual podemos trabalhar/armazenar:**

â€¢ **Integer (inteiro)**: sÃ£o os valores numÃ©ricos inteiros, sem vÃ­rgula decimal, tais como 10, 99, 1000, 9990 etc, assim como valores negativos, como -10, -999 etc.

â€¢ **String (texto)**: sÃ£o os valores compostos por letras ou nÃºmeros, escrito entre aspas, tais como â€œRobertoâ€, â€œVÃ´o 172â€, â€œHello World!â€ etc.

â€¢ **Boolean (booleano ou lÃ³gico)**: podem assumir apenas 2 valores: TRUE ou FALSE, como jÃ¡ conhecemos.

â€¢ **Float (real ou ponto flutuante)**: sÃ£o os valores numÃ©ricos nÃ£o inteiros, com casas decimais, tais como 10.98, 99.9, 1.0000098 etc, assim como seus valores negativos.

Existem tipos de dados sÃ£o chamados de **tipos primitivos**, isto significa que seu **funcionamento e uso** **serÃ¡** exatamente **o mesmo em todas as linguagens de programaÃ§Ã£o**.

2ï¸âƒ£ **Os valores armazenados nas variÃ¡veis podem ser inicializados, atribuÃ­dos ou requisitados**:

â€¢ **InicializaÃ§Ã£o (inicialize)**: inicializaÃ§Ãµes sÃ£o atribuiÃ§Ãµes que **ficam no inÃ­cio do cÃ³digo**. SÃ£o prÃ©-requisito para o funcionamento do restante do algoritmo.

â€¢ **AtribuiÃ§Ã£o (set)**: As atribuiÃ§Ãµes acontecem **sempre que um valor Ã© atribuÃ­do Ã  uma variÃ¡vel**.

â€¢ **RequisiÃ§Ã£o (get)**: a requisiÃ§Ã£o acontece **sempre que um valor armazenado dentro de uma variÃ¡vel Ã© necessÃ¡rio em outro trecho do cÃ³digo**.

ğŸ”´ **Procedimentos (*procedures*):** Os procedimentos ajuda tornando os **cÃ³digos menos repetitivos**. As procedures tambÃ©m podem receber valores para sua execuÃ§Ã£o. Esses valores sÃ£o **variÃ¡veis de entrada** e sÃ£o chamadas de **parÃ¢metros**. podem ser de 2 tipos:

â€¢ **Com retorno (return)**: executa um trecho de cÃ³digo e retorna um valor ao terminar. Por exemplo, uma procedure pode ter um cÃ³digo para executar um cÃ¡lculo e retornar seu resultado.

â€¢ **Sem retorno**: apenas executa seu trecho de cÃ³digo. O uso de **procedures sem retorno** Ã© mais simples, pois nÃ£o possuem retorno (RETURN) e nÃ£o precisam ser atribuÃ­das (depois) de uma variÃ¡vel.

ğŸ”´ **Listas (array** ou **vetores): Ã‰ um tipo de variÃ¡vel que pode armazenar vÃ¡rios valores**, ou seja, sÃ£o vÃ¡rios dados em uma mesma variÃ¡vel usando listas. As listas, tambÃ©m sÃ£o conhecidas como **array** ou **vetores**. **Todos os valores sÃ£o separados por vÃ­rgula e ficam entre colchetes ou parÃªntesis**. Elas funcionam da seguinte forma: Lista_FuncionÃ¡rios = [â€œBrunoâ€, â€œLuizâ€, â€œAnaâ€, â€œJoÃ£oâ€, â€œMoisÃ©sâ€]

Para armazenar vÃ¡rios valores numa Ãºnica variÃ¡vel, **cada item da lista recebe um Ã­ndice, um nÃºmero de posiÃ§Ã£o na lista**, sempre **iniciando em zero**. 

**As listas podem ser** de: nomes (strings), valores numÃ©ricos ou qualquer outro tipo, como valores mistos, armazenando textos, nÃºmeros, valores booleanos, todos misturados.

**ManipulaÃ§Ã£o**: das listas podem variar, isso porque a **manipulaÃ§Ã£o** de seus dados **pode ser realizada de forma diferenciada de uma linguagem para outra**, mas todas seguem os mesmos **conceitos**.

**Os principais conceitos de manipulaÃ§Ã£o de listas**, sÃ£o o da **criaÃ§Ã£o**, a **adiÃ§Ã£o** e a **remoÃ§Ã£o**:

[1] //criaÃ§Ã£o e atribuiÃ§Ã£o
[2] Lista_FuncionÃ¡rios = [â€œBrunoâ€, â€œLuizâ€, â€œAnaâ€]
[3] 
[4] //adiÃ§Ã£o de novo valor apÃ³s a criaÃ§Ã£o da lista 
[5] Lista_FuncionÃ¡rios.Add(â€œMoisÃ©sâ€) 
[6] 
[7] //removendo o segundo item da lista, â€œLuizâ€ (2Âº porque inicia em zero ;-)
[8] Lista_FuncionÃ¡rios.Remove[1]
[9]
[10] //imprime os nomes
[11] print (Lista_FuncionÃ¡rios[0]) //imprime â€œBrunoâ€
[12] print (Lista_FuncionÃ¡rios[1]) //imprime â€œAnaâ€
[13] print (Lista_FuncionÃ¡rios[2]) //imprime â€œMoisÃ©sâ€

**AtenÃ§Ã£o**: Para imprimir um valor, **Ã© preciso usar o seu Ã­ndice** para ter acesso a cada valor isoladamente. Como vimos, **as listas sÃ£o armazenadas com um Ã­ndice**, **sempre iniciando com zero,** isto significa que para saber qual Ã© o Ãºltimo Ã­ndice, basta lembrar que ele Ã© o Ã­ndice de nÃºmero **n-1**, sendo â€œ**nâ€** a quantidade de itens da lista. Por **exemplo**, numa lista com 400 itens, o nÃºmero do Ãºltimo Ã­ndice Ã© 399 (resultado de 400 - 1).

ğŸ”´ **Estruturas de RepetiÃ§Ã£o:** 

ğŸ”º **Loops**: Loops significa **ciclo**. Por exemplo: um aparelho de CD, quando vocÃª coloca um disco, ele inicia tocando na faixa 1, depois passa para a faixa 2 e assim sucessivamente, atÃ© a Ãºltima faixa do disco. O **ciclo desde a primeira faixa atÃ© a Ãºltima Ã© chamado de loop**.

ğŸ”ºÂ **Loop infinito**: **Enquanto nÃ£o houver uma interrupÃ§Ã£o no loop, ele nunca vai ter fim**. Exemplo: Se vocÃª apertar a tecla â€œrepeatâ€ de seu aparelho de CD, assim que acabar a Ãºltima mÃºsica ele reinicia o ciclo e comeÃ§a a tocar a primeira mÃºsica do disco novamente. Isto nunca vai ter fim, sempre que chegar ao fim do disco ele volta para o inÃ­cio, por toda a vida.

ğŸ”º **Tipos de estruturas de repetiÃ§Ã£o de Loops:**

1ï¸âƒ£ **Loop WHILE**: O loop **while** funciona exatamente igual a um CD com repeat, que continua seu ciclo (loop) **enquanto nÃ£o houver** uma interrupÃ§Ã£o. **While significa enquanto** em inglÃªs.

Usamos o **loop while** quando **nÃ£o sabemos** o nÃºmero de eventos que precisam ser executados ou o nÃºmero de dados de uma lista.

**Precisa iniciar com uma pergunta** o cÃ³digo para que o loop inicie, afinal, precisa ter uma fila para iniciar o primeiro atendimento. Sem primeiro atendimento, o loop nÃ£o inicia. EntÃ£o, **a pergunta precisa ser feita antes e ao final do loop while**. A estrutura de repetiÃ§Ã£o while serve para qualquer necessidade.

**WHILE**: usamos para qualquer situaÃ§Ã£o em que precisamos repetir algo atÃ© que uma condiÃ§Ã£o seja satisfeita. Pode ser usada para ler dados de uma lista ou para qualquer outro trecho de cÃ³digo que precisa ser repetido.

2ï¸âƒ£ **Loop FOR EACH**: O **loop for each, significa para cada**, ele se assemelha muito com o play normal do aparelho de CD que, quando tem um CD de 15 mÃºsicas, inicia na primeira mÃºsica e para na Ãºltima. E pronto. **O loop for each nÃ£o precisa de verificaÃ§Ã£o de pergunta no comeÃ§o e antes do final do loop como o while**. o loop for each funciona apenas para listas, pois ele faz uma iteraÃ§Ã£o para cada um de seus itens.

**FOR EACH**: usamos apenas para iterar (percorrer) itens de uma lista. Pudemos ver sua diferenÃ§a com o FOR pois, para cada pasta da pilha de nosso exemplo, ele jÃ¡ tem os dados em si mesmo (FuncionÃ¡rio.Tem_Filhos).

3ï¸âƒ£ **Loop FOR**: O loop FOR Ã© a estrutura de repetiÃ§Ã£o mais organizada das 3 existentes, pois possui uma estrutura mais rÃ­gida que precisa ser seguida. **Seu ciclo de repetiÃ§Ã£o Ã© especÃ­fico e limitado, com conhecimento prÃ©vio de quando inicia e quando termina**. 

**FOR**: usamos para percorrer os Ã­ndices de uma lista ou repetir um trecho de cÃ³digo quando sabemos exatamente a quantidade de vezes que precisam ser repetidas.

O loop FOR precisa ser configurado com 3 informaÃ§Ãµes, e possui o seguinte formato **for (de; atÃ©; passo)**. Vamos conhecer cada parte:
â€¢ **de**: informaÃ§Ã£o da posiÃ§Ã£o com o qual **Ã­ndice serÃ¡ iniciado**, ou seja, sua posiÃ§Ã£o inicial.
â€¢ **atÃ©**: informaÃ§Ã£o da **posiÃ§Ã£o final do** **Ã­ndice**.
â€¢ **passo**: sÃ£o **os passos que o Ã­ndice deve percorrer entre o inÃ­cio e o fim**.

Exemplo de uma estrutura desse loop: **FOR (Ã­ndice = 0; Ã­ndice < 5; Ã­ndice = Ã­ndice + 1)**

Com isso, o loop vai percorrer apenas nessa faixa, parando em 4.

Vamos imaginar 2 situaÃ§Ãµes. Na primeira, eu preciso saber apenas os dados da lista que estÃ£o nos Ã­ndices pares. Para isso, posso simplesmente colocar o passo como Ã­ndice = Ã­ndice + 2. Como o Ã­ndice inicia em zero, o prÃ³ximo serÃ¡ o Ã­ndice 2, o seguinte serÃ¡ o Ã­ndice 4. SÃ³ nÃºmeros pares.

A segunda situaÃ§Ã£o Ã© a seguinte: estou com uma empresa com 400 funcionÃ¡rios e todos estÃ£o numa lista. Eu preciso fazer uma auditoria nos dados destes funcionÃ¡rios, mas sÃ³ em alguns. EntÃ£o, posso programar meu loop for para ter um passo de 10. Assim, vou pegar o funcionÃ¡rio que estÃ¡ na posiÃ§Ã£o 0, depois o funcionÃ¡rio que estÃ¡ na posiÃ§Ã£o 10, o prÃ³ximo que estÃ¡ na posiÃ§Ã£o 20.

![indice do loop FOR.png](Curso%20de%20Programac%CC%A7a%CC%83o%20-%20RECODE%20%F0%9F%92%BB%20d8522a8e2214403d9934ae882b94886b/indice_do_loop_FOR.png)

O algoritmo FOR para este caso ficaria com a seguinte estrutura:

![loop for estrutura do algoritmo.png](Curso%20de%20Programac%CC%A7a%CC%83o%20-%20RECODE%20%F0%9F%92%BB%20d8522a8e2214403d9934ae882b94886b/loop_for_estrutura_do_algoritmo.png)

**As listas possuem um Ã­ndice numÃ©rico e ordenado iniciando sempre em zero. Â Os dicionÃ¡rios (dictionary) sÃ£o listas onde seu Ã­ndice pode ser identificado por texto ou nÃºmero, que Ã© conhecido como chave (key).**

Quando usamos dicionÃ¡rios, as chaves e os valores andam sempre juntos, pois, como podemos perceber, um depende do outro para ter sentido. Eles andam sempre em pares, por isso seus itens sÃ£o chamadosÂ **par chave-valor.**